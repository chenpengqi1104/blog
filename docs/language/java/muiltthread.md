**一、线程池种类**

**1、newCachedThreadPool**

创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。

这种类型的线程池特点是：

工作线程的创建数量几乎没有限制(其实也有限制的,数目为Interger. MAX_VALUE), 这样可灵活的往线程池中添加线程。

如果长时间没有往线程池中提交任务，即如果工作线程空闲了指定的时间(默认为1分钟)，则该工作线程将自动终止。终止后，如果你又提交了新的任务，则线程池重新创建一个工作线程。

在使用CachedThreadPool时，一定要注意控制任务的数量，否则，由于大量线程同时运行，很有会造成系统OOM。

**2、newFixedThreadPool**

创建一个指定工作线程数量的线程池。每当提交一个任务就创建一个工作线程，如果工作线程数量达到线程池初始的最大数，则将提交的任务存入到池队列中。

FixedThreadPool是一个典型且优秀的线程池，它具有线程池提高程序效率和节省创建线程时所耗的开销的优点。但是，在线程池空闲时，即线程池中没有可运行任务时，它不会释放工作线程，还会占用一定的系统资源。

**3、newSingleThreadExecutor**

创建一个单线程化的Executor，即只创建唯一的工作者线程来执行任务，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。如果这个线程异常结束，会有另一个取代它，保证顺序执行。单工作线程最大的特点是可保证顺序地执行各个任务，并且在任意给定的时间不会有多个线程是活动的。

**4、newScheduleThreadPool**

创建一个定长的线程池，而且支持定时的以及周期性的任务执行，支持定时及周期性任务执行。

**5、newSingleThreadScheduledExecutor**

创建一个单线程执行程序，它可安排在给定延迟后运行命令或者定期地执行。线程池中最多执行1个线程，之后提交的线程活动将会排在队列中以此执行并且可定时或者延迟执行线程活动。

**二、线程安全**

1、synchronized修饰方法

2、lock、unlock

从广义上，Java 按照是否对资源加锁分为**乐观锁**和**悲观锁**，它们并不是一种真实存在的锁，而是一种设计思想，乐观锁和悲观锁对于理解 Java 多线程和数据库来说至关重要。

- 悲观锁：对于同一个数据的并发操作，悲观锁认为自己在使用数据的时候一定有别的线程来修改数据，因此在获取数据的时候会先加锁，确保数据不会被别的线程修改。
- 乐观锁：乐观锁认为自己在使用数据时不会有别的线程修改数据，所以不会添加锁，只是在更新数据的时候去判断之前有没有别的线程更新了这个数据。

悲观锁适合写操作多的场景，先加锁可以保证写操作时数据正确。

**三、线程同步**

**1.CountDownLatch：****一个或者多个线程等待n个线程执行完后才能继续执行****。**

CountDownLatch(3); 初始化计数器为3		

 \* 在计数器不为0时所有调用过await()方法的线程都将等待。		

 \* 每当调用一次countDown()时计数器减一		 

\* 直到计数器为0时唤醒所有等待的线程

**2.CyclicBarrier**

 CyclicBarrier 循环屏障 同样也是线程同步工具，区别于CountDownLatch CyclicBarrier 是当一组线程到达确定的点的时候调用了await()，当最后一个线程调用完await()后CyclicBarrier 会释放所有等待中的线程不用像CountDownLatch那样在减一，另外CountDownLatch 初始化后计数器的值不可改变CyclicBarrier在使用完成后计数器可以重置。CyclicBarrier还比CountDownLatch多了一个功能，在所有阻塞线程得以执行的时候CyclicBarrier可以回调一个方法。